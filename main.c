#include <stdio.h>
#include <math.h>
#include <time.h>

int is_prime(int n) {
    for (int div = 2; div <= sqrt(n) + 1; div++) {
        if (n % div == 0) return 0;
    }
    return 1;
}

int find_sum_of_numbers(int n) {
    return n % 10 + (n / 10) % 10 + (n / 100) % 10 + (n / 1000) % 10 + n / 10000;
}


void find_suitable_primes(int s[10000], int sum) {
    int ind = 0;
    for (int n = 10001; n <= 99999; n += 2) {
        if (is_prime(n) && find_sum_of_numbers(n) == sum) s[ind++] = n;
    }
}

int check_sums(int m[5], int sum, int k) {

    if (k == 5) {
        // проверим вертикали
        if (m[0] % 10 + m[1] % 10 + m[2] % 10 + m[3] % 10 + m[4] % 10 != sum) return 0;
        if ((m[0] / 10) % 10 + (m[1] / 10) % 10 + (m[2] / 10) % 10 + (m[3] / 10) % 10 + (m[4] / 10) % 10 != sum) return 0;
        if ((m[0] / 100) % 10 + (m[1] / 100) % 10 + (m[2] / 100) % 10 + (m[3] / 100) % 10 + (m[4] / 100) % 10 != sum) return 0;
        if ((m[0] / 1000) % 10 + (m[1] / 1000) % 10 + (m[2] / 1000) % 10 + (m[3] / 1000) % 10 + (m[4] / 1000) % 10 != sum) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 10000) % 10 + (m[2] / 10000) % 10 + (m[3] / 10000) % 10 + (m[4] / 10000) % 10 != sum) return 0;
        // проверим диагонали
        if (m[0] % 10 + (m[1] / 10) % 10 + (m[2] / 100) % 10 + (m[3] / 1000) % 10 + (m[4] / 10000) % 10 != sum) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 1000) % 10 + (m[2] / 100) % 10 + (m[3] / 10) % 10 + m[4] % 10 != sum) return 0;
    }
    if (k == 4) {
        // проверим вертикали
        if (m[0] % 10 + m[1] % 10 + m[2] % 10 + m[3] % 10 + 1 <= sum > m[0] % 10 + m[1] % 10 + m[2] % 10 + m[3] % 10 + 9) return 0;
        if ((m[0] / 10) % 10 + (m[1] / 10) % 10 + (m[2] / 10) % 10 + (m[3] / 10) % 10 + 1 <= sum > (m[0] / 10) % 10 + (m[1] / 10) % 10 + (m[2] / 10) % 10 + (m[3] / 10) % 10 + 9) return 0;
        if ((m[0] / 100) % 10 + (m[1] / 100) % 10 + (m[2] / 100) % 10 + (m[3] / 100) % 10 + 1 <= sum > (m[0] / 100) % 10 + (m[1] / 100) % 10 + (m[2] / 100) % 10 + (m[3] / 100) % 10 + 9) return 0;
        if ((m[0] / 1000) % 10 + (m[1] / 1000) % 10 + (m[2] / 1000) % 10 + (m[3] / 1000) % 10 + 1 <= sum > (m[0] / 1000) % 10 + (m[1] / 1000) % 10 + (m[2] / 1000) % 10 + (m[3] / 1000) % 10 + 9) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 10000) % 10 + (m[2] / 10000) % 10 + (m[3] / 10000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 10000) % 10 + (m[2] / 10000) % 10 + (m[3] / 10000) % 10 + 9) return 0;
        // проверим диагонали
        if (m[0] % 10 + (m[1] / 10) % 10 + (m[2] / 100) % 10 + (m[3] / 1000) % 10 + 1 <= sum > m[0] % 10 + (m[1] / 10) % 10 + (m[2] / 100) % 10 + (m[3] / 1000) % 10 + 9) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 1000) % 10 + (m[2] / 100) % 10 + (m[3] / 10) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 1000) % 10 + (m[2] / 100) % 10 + (m[3] / 10) % 10 + 9) return 0;
    }
    if (k == 3) {
        // проверим вертикали
        if (m[0] % 10 + m[1] % 10 + m[2] % 10 + 1 <= sum > m[0] % 10 + m[1] % 10 + m[2] % 10 + 9 * 2) return 0;
        if ((m[0] / 10) % 10 + (m[1] / 10) % 10 + (m[2] / 10) % 10 + 1 <= sum > (m[0] / 10) % 10 + (m[1] / 10) % 10 + (m[2] / 10) % 10+ 9 * 2) return 0;
        if ((m[0] / 100) % 10 + (m[1] / 100) % 10 + (m[2] / 100) % 10 + 1 <= sum > (m[0] / 100) % 10 + (m[1] / 100) % 10 + (m[2] / 100) % 10 + 9 * 2) return 0;
        if ((m[0] / 1000) % 10 + (m[1] / 1000) % 10 + (m[2] / 1000) % 10 + 1 <= sum > (m[0] / 1000) % 10 + (m[1] / 1000) % 10 + (m[2] / 1000) % 10 + 9 * 2) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 10000) % 10 + (m[2] / 10000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 10000) % 10 + (m[2] / 10000) % 10 + 9 * 2) return 0;
        // проверим диагонали
        if (m[0] % 10 + (m[1] / 10) % 10 + (m[2] / 100) % 10 + 1 <= sum > m[0] % 10 + (m[1] / 10) % 10 + (m[2] / 100) % 10 + 9 * 2) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 1000) % 10 + (m[2] / 100) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 1000) % 10 + (m[2] / 100) % 10 + 9 * 2) return 0;
    }
    if (k == 2) {
        // проверим вертикали
        if (m[0] % 10 + m[1] % 10 + 1 <= sum > m[0] % 10 + m[1] % 10 + 9 * 3) return 0;
        if ((m[0] / 10) % 10 + (m[1] / 10) % 10 + 1 <= sum > (m[0] / 10) % 10 + (m[1] / 10) % 10 + 9 * 3) return 0;
        if ((m[0] / 100) % 10 + (m[1] / 100) % 10 + 1 <= sum > (m[0] / 100) % 10 + (m[1] / 100) % 10 + 9 * 3) return 0;
        if ((m[0] / 1000) % 10 + (m[1] / 1000) % 10 + 1 <= sum > (m[0] / 1000) % 10 + (m[1] / 1000) % 10 + 9 * 3) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 10000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 10000) % 10 + 9 * 3) return 0;
        // проверим диагонали
        if (m[0] % 10 + (m[1] / 10) % 10 + 1 <= sum > m[0] % 10 + (m[1] / 10) % 10 + 9 * 3) return 0;
        if ((m[0] / 10000) % 10 + (m[1] / 1000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + (m[1] / 1000) % 10 + 9 * 3) return 0;
    }
    if (k == 1) {
        // проверим вертикали
        if (m[0] % 10 + 1 <= sum > m[0] % 10 + 9 * 4) return 0;
        if ((m[0] / 10) % 10 + 1 <= sum > (m[0] / 10) % 10 + 9 * 4) return 0;
        if ((m[0] / 100) % 10 + 1 <= sum > (m[0] / 100) % 10 + 9 * 4) return 0;
        if ((m[0] / 1000) % 10 + 1 <= sum > (m[0] / 1000) % 10 + 9 * 4) return 0;
        if ((m[0] / 10000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + 9 * 4) return 0;
        // проверим диагонали
        if ((m[0] % 10 + 1 <= sum > m[0] % 10 + 9 * 4)) return 0;
        if (((m[0] / 10000) % 10 + 1 <= sum > (m[0] / 10000) % 10 + 9 * 4)) return 0;
    }
    return 1;
}

int check_primes(int m[5], int k, int primes[10000]) {
    if (k == 0) return 1;
    if (k == 1) {
        return 1; }
    if (k == 2) {
        return 1; }
    if (k == 3) {
        return 1; }
    if (k == 4) {
        return 1; }
    if (k == 5) {
        int s[7];
        s[0] = m[0] % 10 * 10000 + m[1] % 10 * 1000 + m[2] % 10 * 100 + m[3] % 10 * 10 + m[4] % 10;
        s[1] = (m[0] / 10) % 10 * 10000 + (m[1] / 10) % 10 * 1000 + (m[2] / 10) % 10 * 100 + (m[3] / 10) % 10 * 10 + (m[4] / 10) % 10;
        s[2] = (m[0] / 100) % 10 * 10000 + (m[1] / 100) % 10 * 1000 + (m[2] / 100) % 10 * 100 + (m[3] / 100) % 10 * 10 + (m[4] / 100) % 10;
        s[3] = (m[0] / 1000) % 10 * 10000 + (m[1] / 1000) % 10 * 1000 + (m[2] / 1000) % 10 * 100 + (m[3] / 1000) % 10 * 10 + (m[4] / 1000) % 10;
        s[4] = (m[0] / 10000) % 10 * 10000 + (m[1] / 10000) % 10 * 1000 + (m[2] / 10000) % 10 * 100 + (m[3] / 10000) % 10 * 10 + (m[4] / 10000) % 10;
        s[5] = m[0] % 10 * 10000 + (m[1] / 10) % 10 * 1000 + (m[2] / 100) % 10 * 100 + (m[3] / 1000) % 10 * 10 + (m[4] / 10000) % 10;
        s[6] = (m[0] / 10000) % 10 * 10000 + (m[1] / 1000) % 10 * 1000 + (m[2] / 100) % 10 * 100 + (m[3] / 10) % 10 * 10 + m[4] % 10;
        for (int c = 0; c < 7; c++) {
            int fl = 0;
            for (int i = 0; primes[i]; i++) {
                if (s[c] == primes[i]) { fl = 1; break; }
            }
            if (fl == 0) return 0;
        }
        return 1;
    }
}


void backtracking(int m[5], int k, int sum, int first, int primes[10000], FILE *fout){
    if (check_sums(m, sum, k) && check_primes(m, k, primes)) {

        if (k == 5) {
            for (int i = 0; i < 5; i++) fprintf(fout, "%d\n", m[i]);
            fprintf(fout, "\n");
        }
        else
            for (int i = 0; primes[i]; i++) {
                if (k == 0 && primes[i] / 10000 < first) continue; // если первая цифра меньше нужной пропускаем шаг
                if (k == 0 && primes[i] / 10000 > first) break; // если первая цифра больше => прекращаем поиск
                m[k] = primes[i];
                backtracking(m, k + 1, sum, first, primes, fout);
            }
    }


    // fprintf(fout, "no matrix with sum == %d and first == %d found", s, f);
}



int main() {
    FILE *fin, *fout;
    fin = fopen("input.txt", "r");
    fout = fopen("output.txt", "w");
    int sum, first;
    fscanf(fin, "%d\n%d", &sum, &first);
    int matrix[5];
    int primes[10000];
    find_suitable_primes(primes, sum);
    // for (int i = 0; primes[i]; i++) {
       //  printf("%d\n", primes[i]);
    // }

    double time_spent = 0.0;
    clock_t begin = clock();

    backtracking(matrix, 0, sum, first, primes, fout);

    clock_t end = clock();
    time_spent += (double)(end - begin) / CLOCKS_PER_SEC;
    printf("The elapsed time is %f seconds", time_spent);
    return 0;
}
